{"version":3,"sources":["Util.js","Util.ts"],"names":["exports","__esModule","fs","require","Path","guid","s4","Math","floor","random","toString","substring","copyFileSync","source","target","targetFile","existsSync","lstatSync","isDirectory","join","basename","writeFileSync","readFileSync","copyFolderRecursiveSync","useOldName","files","targetFolder","mkdirSync","readdirSync","forEach","file","curSource","deleteFolderRecursive","path","curPath","unlinkSync","rmdirSync"],"mappings":"AAAA;;AACAA,QAAQC,UAAR,GAAqB,IAArB;ACDA,IAAAC,KAAAC,QAAA,IAAA,CAAA;AACA,IAAAC,OAAAD,QAAA,MAAA,CAAA;AAmBA;;;;;;;;;;;;AAYA,SAASE,IAAT,GAAa;AACX,aAASC,EAAT,GAAW;AACT,eAAOC,KAAKC,KAAL,CAAW,CAAC,IAAID,KAAKE,MAAL,EAAL,IAAsB,OAAjC,EACJC,QADI,CACK,EADL,EAEJC,SAFI,CAEM,CAFN,CAAP;AAGD;AACD,WACEL,OACAA,IADA,GAEA,GAFA,GAGAA,IAHA,GAIA,GAJA,GAKAA,IALA,GAMA,GANA,GAOAA,IAPA,GAQA,GARA,GASAA,IATA,GAUAA,IAVA,GAWAA,IAZF;AAcD;AAkGCN,QAAAK,IAAA,GAAAA,IAAA;AAhGF;;;;;;;;;;;;;AAaA,SAASO,YAAT,CAAsBC,MAAtB,EAA8BC,MAA9B,EAAoC;AAClC,QAAIC,aAAaD,MAAjB;AACA,QAAIZ,GAAGc,UAAH,CAAcF,MAAd,CAAJ,EAA2B;AACzB,YAAIZ,GAAGe,SAAH,CAAaH,MAAb,EAAqBI,WAArB,EAAJ,EAAwC;AACtCH,yBAAaX,KAAKe,IAAL,CAAUL,MAAV,EAAkBV,KAAKgB,QAAL,CAAcP,MAAd,CAAlB,CAAb;AACD;AACF;AACDX,OAAGmB,aAAH,CAAiBN,UAAjB,EAA6Bb,GAAGoB,YAAH,CAAgBT,MAAhB,CAA7B;AACD;AA4ECb,QAAAY,YAAA,GAAAA,YAAA;AA1EF;;;;;;;;;;;;;;AAcA,SAASW,uBAAT,CACEV,MADF,EAEEC,MAFF,EAGEU,UAHF,EAG4B;AAA1B,QAAAA,eAAA,KAAA,CAAA,EAAA;AAAAA,qBAAA,IAAA;AAA0B;AAE1B,QAAIC,QAAQ,EAAZ;AACA,QAAIC,eAAeZ,MAAnB;AACA,QAAIU,UAAJ,EAAgBE,eAAetB,KAAKe,IAAL,CAAUL,MAAV,EAAkBV,KAAKgB,QAAL,CAAcP,MAAd,CAAlB,CAAf;AAChB,QAAI,CAACX,GAAGc,UAAH,CAAcU,YAAd,CAAL,EAAkC;AAChCxB,WAAGyB,SAAH,CAAaD,YAAb;AACD;AACD,QAAIxB,GAAGe,SAAH,CAAaJ,MAAb,EAAqBK,WAArB,EAAJ,EAAwC;AACtCO,gBAAQvB,GAAG0B,WAAH,CAAef,MAAf,CAAR;AACAY,cAAMI,OAAN,CAAc,UAASC,IAAT,EAAa;AACzB,gBAAIC,YAAY3B,KAAKe,IAAL,CAAUN,MAAV,EAAkBiB,IAAlB,CAAhB;AACA,gBAAI5B,GAAGe,SAAH,CAAac,SAAb,EAAwBb,WAAxB,EAAJ,EAA2C;AACzCK,wCAAwBQ,SAAxB,EAAmCL,YAAnC;AACD,aAFD,MAEO;AACLd,6BAAamB,SAAb,EAAwBL,YAAxB;AACD;AACF,SAPD;AAQD;AACF;AAuCC1B,QAAAuB,uBAAA,GAAAA,uBAAA;AArCF;;;;;;;;;;;;AAYA,SAASS,qBAAT,CAA+BC,IAA/B,EAAgD;AAC9C,QAAI/B,GAAGc,UAAH,CAAciB,IAAd,CAAJ,EAAyB;AACvB/B,WAAG0B,WAAH,CAAeK,IAAf,EAAqBJ,OAArB,CAA6B,UAASC,IAAT,EAAa;AACxC,gBAAII,UAAUD,OAAO,GAAP,GAAaH,IAA3B;AACA,gBAAI5B,GAAGe,SAAH,CAAaiB,OAAb,EAAsBhB,WAAtB,EAAJ,EAAyC;AACvC;AACAc,sCAAsBE,OAAtB;AACD,aAHD,MAGO;AACL;AACAhC,mBAAGiC,UAAH,CAAcD,OAAd;AACD;AACF,SATD;AAUAhC,WAAGkC,SAAH,CAAaH,IAAb;AACD;AACF;AAYCjC,QAAAgC,qBAAA,GAAAA,qBAAA","file":"Util.js","sourcesContent":["\"use strict\";\nexports.__esModule = true;\nvar fs = require(\"fs\");\nvar Path = require(\"path\");\n/**\n * @function guid\n * @author Minimine <https://github.com/miniminelp>\n * @since 0.0.1\n * @version 0.0.1\n * @license MIT\n * @copyright (c) Minimine 2018\n *\n * @description returns a random uuid\n * @return random uuid\n *\n */\nfunction guid() {\n    function s4() {\n        return Math.floor((1 + Math.random()) * 0x10000)\n            .toString(16)\n            .substring(1);\n    }\n    return (s4() +\n        s4() +\n        \"-\" +\n        s4() +\n        \"-\" +\n        s4() +\n        \"-\" +\n        s4() +\n        \"-\" +\n        s4() +\n        s4() +\n        s4());\n}\nexports.guid = guid;\n/**\n * @function copyFileSync\n * @author Minimine <https://github.com/miniminelp>\n * @since 0.0.3\n * @version 0.0.3\n * @license MIT\n * @copyright (c) Minimine 2018\n *\n * @description copys a file\n * @param source the source file\n * @param target the paste target\n *\n */\nfunction copyFileSync(source, target) {\n    var targetFile = target;\n    if (fs.existsSync(target)) {\n        if (fs.lstatSync(target).isDirectory()) {\n            targetFile = Path.join(target, Path.basename(source));\n        }\n    }\n    fs.writeFileSync(targetFile, fs.readFileSync(source));\n}\nexports.copyFileSync = copyFileSync;\n/**\n * @function copyFolderRecursiveSync\n * @author Minimine <https://github.com/miniminelp>\n * @since 0.0.3\n * @version 0.0.3\n * @license MIT\n * @copyright (c) Minimine 2018\n *\n * @description copys a folder recursively\n * @param source the source folder\n * @param target the paste target\n * @param useOldName should a sub folder created with the old name? default: true\n *\n */\nfunction copyFolderRecursiveSync(source, target, useOldName) {\n    if (useOldName === void 0) { useOldName = true; }\n    var files = [];\n    var targetFolder = target;\n    if (useOldName)\n        targetFolder = Path.join(target, Path.basename(source));\n    if (!fs.existsSync(targetFolder)) {\n        fs.mkdirSync(targetFolder);\n    }\n    if (fs.lstatSync(source).isDirectory()) {\n        files = fs.readdirSync(source);\n        files.forEach(function (file) {\n            var curSource = Path.join(source, file);\n            if (fs.lstatSync(curSource).isDirectory()) {\n                copyFolderRecursiveSync(curSource, targetFolder);\n            }\n            else {\n                copyFileSync(curSource, targetFolder);\n            }\n        });\n    }\n}\nexports.copyFolderRecursiveSync = copyFolderRecursiveSync;\n/**\n * @function deleteFolderRecursive\n * @author Minimine <https://github.com/miniminelp>\n * @since 0.0.3\n * @version 0.0.3\n * @license MIT\n * @copyright (c) Minimine 2018\n *\n * @description deletes a folder recursively\n * @param path the folder to delete\n *\n */\nfunction deleteFolderRecursive(path) {\n    if (fs.existsSync(path)) {\n        fs.readdirSync(path).forEach(function (file) {\n            var curPath = path + \"/\" + file;\n            if (fs.lstatSync(curPath).isDirectory()) {\n                // recurse\n                deleteFolderRecursive(curPath);\n            }\n            else {\n                // delete file\n                fs.unlinkSync(curPath);\n            }\n        });\n        fs.rmdirSync(path);\n    }\n}\nexports.deleteFolderRecursive = deleteFolderRecursive;\n","import * as fs from \"fs\";\r\nimport * as Path from \"path\";\r\n\r\n/**\r\n * @function CallbackFunction\r\n * @author Minimine <https://github.com/miniminelp>\r\n * @since 0.0.3\r\n * @version 0.0.3\r\n * @license MIT\r\n * @copyright (c) Minimine 2018\r\n *\r\n * @description A callback function type\r\n * @param err the error (Error | undefined)\r\n * @param res the result (String | undefined)\r\n *\r\n */\r\ninterface CallbackFunction {\r\n  (err?: Error | undefined, res?: any | undefined): void;\r\n}\r\n\r\n/**\r\n * @function guid\r\n * @author Minimine <https://github.com/miniminelp>\r\n * @since 0.0.1\r\n * @version 0.0.1\r\n * @license MIT\r\n * @copyright (c) Minimine 2018\r\n *\r\n * @description returns a random uuid\r\n * @return random uuid\r\n *\r\n */\r\nfunction guid() {\r\n  function s4() {\r\n    return Math.floor((1 + Math.random()) * 0x10000)\r\n      .toString(16)\r\n      .substring(1);\r\n  }\r\n  return (\r\n    s4() +\r\n    s4() +\r\n    \"-\" +\r\n    s4() +\r\n    \"-\" +\r\n    s4() +\r\n    \"-\" +\r\n    s4() +\r\n    \"-\" +\r\n    s4() +\r\n    s4() +\r\n    s4()\r\n  );\r\n}\r\n\r\n/**\r\n * @function copyFileSync\r\n * @author Minimine <https://github.com/miniminelp>\r\n * @since 0.0.3\r\n * @version 0.0.3\r\n * @license MIT\r\n * @copyright (c) Minimine 2018\r\n *\r\n * @description copys a file\r\n * @param source the source file\r\n * @param target the paste target\r\n *\r\n */\r\nfunction copyFileSync(source, target) {\r\n  var targetFile = target;\r\n  if (fs.existsSync(target)) {\r\n    if (fs.lstatSync(target).isDirectory()) {\r\n      targetFile = Path.join(target, Path.basename(source));\r\n    }\r\n  }\r\n  fs.writeFileSync(targetFile, fs.readFileSync(source));\r\n}\r\n\r\n/**\r\n * @function copyFolderRecursiveSync\r\n * @author Minimine <https://github.com/miniminelp>\r\n * @since 0.0.3\r\n * @version 0.0.3\r\n * @license MIT\r\n * @copyright (c) Minimine 2018\r\n *\r\n * @description copys a folder recursively\r\n * @param source the source folder\r\n * @param target the paste target\r\n * @param useOldName should a sub folder created with the old name? default: true\r\n *\r\n */\r\nfunction copyFolderRecursiveSync(\r\n  source: string,\r\n  target: string,\r\n  useOldName: boolean = true\r\n) {\r\n  var files = [];\r\n  var targetFolder = target;\r\n  if (useOldName) targetFolder = Path.join(target, Path.basename(source));\r\n  if (!fs.existsSync(targetFolder)) {\r\n    fs.mkdirSync(targetFolder);\r\n  }\r\n  if (fs.lstatSync(source).isDirectory()) {\r\n    files = fs.readdirSync(source);\r\n    files.forEach(function(file) {\r\n      var curSource = Path.join(source, file);\r\n      if (fs.lstatSync(curSource).isDirectory()) {\r\n        copyFolderRecursiveSync(curSource, targetFolder);\r\n      } else {\r\n        copyFileSync(curSource, targetFolder);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * @function deleteFolderRecursive\r\n * @author Minimine <https://github.com/miniminelp>\r\n * @since 0.0.3\r\n * @version 0.0.3\r\n * @license MIT\r\n * @copyright (c) Minimine 2018\r\n *\r\n * @description deletes a folder recursively\r\n * @param path the folder to delete\r\n *\r\n */\r\nfunction deleteFolderRecursive(path: fs.PathLike) {\r\n  if (fs.existsSync(path)) {\r\n    fs.readdirSync(path).forEach(function(file) {\r\n      var curPath = path + \"/\" + file;\r\n      if (fs.lstatSync(curPath).isDirectory()) {\r\n        // recurse\r\n        deleteFolderRecursive(curPath);\r\n      } else {\r\n        // delete file\r\n        fs.unlinkSync(curPath);\r\n      }\r\n    });\r\n    fs.rmdirSync(path);\r\n  }\r\n}\r\n\r\ninterface Map<V> {\r\n  [key: string]: V;\r\n}\r\n\r\nexport {\r\n  CallbackFunction,\r\n  Map,\r\n  guid,\r\n  copyFileSync,\r\n  copyFolderRecursiveSync,\r\n  deleteFolderRecursive\r\n};\r\n"]}